Procedure oriented programming
	focuses on task/procedure/function

	flyRocket
	
Object oriented programming
	focuses on component and functionality of systems
	Modular approach
	Rocket
		has-a : combustion engine, exhaust chamber,
			cockpit
			
	combustion engine		
		does : burn fuel
		
	exhaust chamber
		does : exhaust energy in downward direction

	cockpit
		does : life support 
			
			
Object
	has
	does
	
	
	
	
Rock
	has - iron, nitorgen
	does - throw
	
	
GmailAccount
	has - email, inbox, sentb
	does - 
		send email,delete email, read email
		
		
		
BankAccount
	// composition = bank account made up of
	has - balance, accountNumber,customername,phone ( VARIABLE )
	
	// action/functionality/features
	does - 
		deposit (METHOD)
			balance increases (LOGIC/ALGORITHM) Operators and Control flows
		withdraw(METHOD)
			balance decreases(LOGIC/ALGORITHM)
		
public class BankAccount{
	int balance=100;
	int phone=123;
	public void withdraw(int withdrawAmount){
		balance=balance-withdrawAmount;
	}
	public void deposit(int amount){
		balance=balance+amount;
	}
}




Inheritance : Reusability

	Iphone -- 2006  (10 years R and D)
		call, text, camera, browse
	Iphone3 -- 2007
		call, text, camera, browse, Apple map
	Iphone4 -- 2008
		call, text, camera, browse, Apple map, Apple pay


curly brackets or blocks

Shopping page{
	buy{
		add items to my cart
	}
	checkout{
		use credit card for payment
	}
}
welcome page{
	login{
		enter userid and passwrod
	}
	register{
		enter userid and password and phone
	}
}

www.amazon.com

com.amazon.www.login
	Login.java
	Register.java

com.amazon.www.browsing
	shopping.java
	payment.java


variable cannot have value




Person
	// long term
	name=john // specific to each person (Instance variable)
	species=human // shared by every person (static variable)
	
	// short term
	add 2,5,7 // input/parametric variable
	answer = 7 , 7 // lo			
			= 14
			
			
			
*************** method declaration *****************
program that provides service
	
	what is the name of service/action ?  locateRestaurant
	how many inputs ? what is the data type of each input ?
		1 ,	restaurantName		String
	how many output ? what is the data type of each output ?
		4, String street , String ciity, String state, int zip

	// public, input	= optional
	// output, name = mandatory
	
	public 	output		name(	input )
	
	Input
		0 : leave it blank
		1 : write the data type followed by name of the input
		more : a) write multiple data_type input_name comma separated
			b) create new complex program that can hold all the multiple output
			mention the name of that program
	Output
		0 : void
		1 : data type of output
		more : create new complex program that can hold all the multiple output
			mention the name of that program

	public 	int		add   (int number1,int number2	)
	public 	int		areaOfRectangle( int length   , int breadth  )
	public	boolean	login( String email , String password  )
	public	RestauAddress	locateRestaurant( String restaurantName) 
	
	public int add(int a,int b)
	// blue print
	public class RestauAddress{
		String street;
		String ciity;
		String state;
		int zip;
	}


*************8

shopping.java

companyName = shared (static global)
CartItem = specific (instance global)
productToBuy = input (parameteric)
TotalCost =  (local)
public class shopping{
	static String companyName;
	String cartItem;
	
	public void buy(String productToBuy){
		int TotalCost;
	}
	
}

blocks defines boundary of programs and section in program

Banking {
	withdraw{
		deduct money
	}
	deposit{
		increase money
	}
}



Shopping{
	checkout
	makepayment
	browse
	show product
}

differntiate variable...  value

variable dont have quotes = "john" , 'j' , abcd : abcd
variables dont start with a number = 123 , "123" , a123 : a123 
variables are not address = #abc, "new york" , newyork :  newyork

values start with quotes = 'j' , john, a123 : 'j'
value can be a whole or fraction number = 123, 123a , 12.a , 12.35 :  123 , 12.35
values can be address = (complex data type) "new york", 12345, #abc : #abc


*** RHS = if you see a variable. replace that with its value ***
*** RHS ALWAYS resovles to a single value that matches LHS data type ****


int x=10;
int y=20;
int z=x+30;
	int z=10+30;
	int z=40;
int a=x+y+10;
	int a=10+20+10;
	int a=40
int b=30;
int c=add(x,y);
	int c=add(10,20); // replace all variable with its value
	int c=add(10,20); // give control to add method
	int c=replace whatever add method returned back
	int c=30;
String john="john";
String doe="doe";
String fullName1= john + "joe";
	String fullName1= "john" + "joe";
	String fullName1= "johnjoe";
String fullName1= john + doe;
	String fullName1= "john"+"doe";
	String fullName1= "johndoe";

	


variable = value;

LHS   RHS
10 == 20 (NO.. false)
5 == 5 ( YES... true)

20 == john

true = 120.3

true==true
john==jane
12.2=12.2
'a'='a'


10 greater than 5 ? true
5 is less than 2 ? false
john is less than mike ? 


-( + 5  ) = -5
- ( - 5) = +5


++ = increment operator (increase by 1 )
-- = decrerement operator ( decreases by 1)


cart
	iphone  800$ . 2 orders
	samsung 500$ . 1 orders
	moto 300$ . 2 orders
	
logical / conditional operator
operates on boolean

output is boolean

BOTH
true and true = true
true and false = false
false and true = false
false and false = false

CHOICE
true or true = true
true or false = true
false or true = true
false or false = false

operator precedence(priority)
1) brackets ()
2) * / %
3) + - 
4) > <
5) ||
6) more than 1 operator with same priotity ... process Left to right

int aa=5;
int bb=7;
int cc=6;
int dd=10;

aa+bb*cc+(dd+aa)*bb > cc || aa < bb
5+7*6+(10+5)*7 > 6 || 5 < 7
5+7*6+15*7 > 6 || 5 < 7
5+42+15*7 > 6 || 5 < 7
5+42+105 > 6 || 5 < 7
47+105 > 6 || 5 < 7
152 > 6 || 5 < 7
true || 5 < 7
true || true
true

**************** control flow *************

for : fixed loop
while : 0 or more loop
do-while : 1 or more loop

Shopping : add items to the cart 1 by 1 (WHILE)
ATM : do transaction 1 by 1 (DO-WHILE)
Flight AA123 seat booking : book each seat 1 by 1 (FOR)

For loop
for( initializing ;condition stop; modification){
	Repeating code
}
// infinite loop
for( int i=1 ; i<=3 ; i++){
	sysout("hi");
}

I C R 	= i-1,	true	print hi
M C R	= i-2,	true	print hi
M C R	= i-3,	true	print hi
M C R	= i-4,	false
M C R	


continue : skip all lines in current loop .. and CONTINUE to next loop
break : EXIT..

for( int i=1 ; i<=3 ; i++){
	sysout("hi");
	if(i==2){
		break;
	}
	sysout("bye");
}

I C R 	=	i-1,	true,	print hi	print bye
M C R	=	i-2,	true,	print hi
M C R	=
M C R	=
M C R	


while( boolean condition ){



}


in-built or library program : written by others
	and used by us
	Thread
	collection
	sysout
	scanner
	String
user-defined program : programmer write

int a=10; // a is variable of data type int
Calculator c=new Calculator(); //
	// calculator is a program.. c is reference variable
	// pointing to calculator program
Scanner sc=new Scanner(System.in);	
	// Scanner is a program.. sc is refernce variable
	// pointing to scanner program
Scanner has the code that allows to take input
from screen

MULTIPLE CHOICE - control flow

int choice=123; 
String name="john";
if( choice== 1) {
	System.out.println(" enter withdraw amount");
}
else if( choice== 2) {
	// if you enter one of the block .. you exit this sequence entirely
	System.out.println(" enter deposit amount");
}
else if(name=="john") {
	System.out.println(" your balance is 100$");
}

performance is slower than switch case
switch case operates on primitive and String
	data type
if-else if allows to define complex/multiple conditions
	and match any conditions

if( userid=loginuserid && pwd=loginpwd) {
	System.out.println(" welcome to website");
}
else if( phone=loginphone && pwd=loginpwd) {
	System.out.println(" welcome to website");
}
else if( email=loginemail && pwd=loginpwd) {
	System.out.println(" welcome to website");
}


method call passing input rules
	number of inputs
	type of inputs
	order of inputs

Constructor call has same input rules as above





****************** INHERITANCE ****************** 


Super > Sub class
Parent > Child class


extends
multiple inheritance
multilevel inheritance
overriding
super
constructor behaviour in inheritance



Concrete program : has solution for all methods
	100% complete program
abstract program : does not has solution for all methods
	incomplete program
partial abstract program : there are some solution and some dont have solution for method
	partial complete program
	
	
LHS=RHS should be same
int a=10;
int b=30;
a=b; // LHS and RHS should be same
	
RHS can be same as LHS
OR
RHS can be child of LHS AND is also concrete program

interface = 100% incomplet program
abstract = partial complete program
concrete = 100% compelte program

interface 	> abstract > concrete > concrete
Food 	> Tomato 	> pizza	 > hawaianPizza

interface 	> abstract > concrete	  >  concrete
ICar 		> Nissan   > NextGenNissan > NissanZ60

Food f=new Food(); // NO .. food is incomplete program
ICar ic=new Nissan(); // NO... Nissan is related to ICar however not a complete (abstract/partial)
Food f=new NextGenNissan(); // NO... NextGenNissan is concrete however not related to Food
Tomato t=new pizza(); // YES... pizza is child/related to tomato... also concrete program
NextGenNissan ngn=new Nissan();// NO... Nissan is NOT child of NextGenNissan or concrete program
hawaianPizza hp=new pizza(); // NO... pizza is NOT child of hawaianPizza
Icar ic=new NissanZ60(); // YES... 


IIphone= 3 incompete method ( PLAN / IDEA )
	call
	text
	default browse(){
		asdasdasd
	}
	
Iphone3 implements IIphone = 2 complete methods 
	call
		code
	text
		code
		
Iphone4 extends Iphone3 = 3 complete methods 
	map
		code

Iphone5 extends Iphone4 = 4 complete mthods 
	fingerPrintScan
		code

IphoneX extends Iphone5 = 5 complete methods  
	facialRecogScan
		code
		
FORWARD looking
Backward compatibility issue = default methods ( interface are allowed to have complete methods/ method logic/body)


Solution for Backward compatibility issue =Default methods(contains logic/method body)
Default methods intrdoduced Diamond problem
Solution for diamond problem was Overriding


Abstract class - Generalization

Car Manufacture Nissan

Nissan SE = 20,000
Nissan LE = LCD display 25000
Nissan CE = moonroof and LCD 28000
Nissan Limited Edition = rearview camera, parking assit etc 32000

4 big factories for all 4 model = EXPENSIVE
Generalization
	1 Big factory = 90% of components for all 4 models
	1 small factory = assemble LCD
	1 small factory = camera
	1 small factory = praking assistance
	
	
WITHOUT ABSTRACT DESIGN
	not convinient/flexible for changes in existing features
	new features addition requires changes in all places
	
WITH ABSTRACT DESIGN
IPayment - 3 incomplete
	ShippingAddress
	Contact 
	payment
	advertisement
abstract class AbsPayment implements IPayment
	ShippingAddress
		code
	Contact 
		code email and phone
	advertisement
		sell amazon card code
CreditCard extends AbsPayment 
	payment
		code
	 
Paypal  extends AbsPayment 
	payment
		code
	  
Crypto  extends AbsPayment 
	payment
		code
	 
********** poly morphism *****

compiletime- overloading
	same method name and different input
	can be in same class or in parent and child class
	
runtime - overriding
	same method name and SAME input
	can be only across parent and child
	
	
********

public int add(int a, int b){
	return a+b;
}

add("john",12); // add requires 2 int.... passsing 1 string and 1 int
add(10,12);

NEW RULE FOR METHOD CALL WITH inheritance

you can pass a variable of same type
iphone > iphone3 > iphoneX
food > tomato > pizza

Iphone i=new Iphone();
Iphone3 i3=new Iphone3();
IphoneX iX=new IphoneX();
food f=new Food();
tomato t=new tomato();
pizza p=new pizza();

// u can pass any variable that is of same type
	test( i  ); // BASIC rule
// OR any child of input data type
	test(i3);
	test(iX);
public void test(Iphone ip){
}

************** String ***********

String pool : Objects in pool are shared by identical value variables
String immutable : object in pool cannot be changed. ( changing
	value for one might change value for all variable sharing 
	that address)
benefits of pool : sharing will save lot of memory
issues with immutable : more changes will results in new objects
	created every time
soltion of immutable issue : stringbuffer and string builder
difference between literal value and new value :
	literal value are created inside pool
	new value are created outside pool
	
String phone="1234567890";
String phone="(123)4567890";

String phone="123-456-7890";
phone=phone.replaceAll("-","");
1234567890

String phone="123-456-7890";
phone=phone.replaceFirst("-","");
123456-7890	


String fullName="john doe";
String[] fullNameSplit=fullName.split(" "); // string array... group of string vlues
fullNameSplit[0] // john
fullNameSplit[1] // doe



String name="john doe";
name.substring(2); // starting from position 2 till the end : "hn doe"
name.substring(2,6); // starting from position 2 till the position 6(not including 6)
				// "hn d"

************* exception handling ****************

Customer : what should customer do if software fails/crashes ?
	1) what the customers can do to avoid this failure in future. Simple message
		that customers can understand
	2) Custom error message for every problem

Developer : what is the reason for software fails/crashes ?
	1) why did program fail ( first line in error message )
	2) where is the problem in program ( first line that starts with "at " )

try : write the code where we suspect program might fail
catch : in the event of failure ... this is where we take counter action
	to address the problem
finally : mandatory code block

	// simple code that never throws error
	sysout("welcome to bank");
	try{ // code that we suspect might fail
		// this line might fail, if customer atm card is damaged
		swipe atm card
	}
	catch(Exception e){// safety net // optional code
		// if above line fails..
		sysout(" please call 1800, request for new card");
	}
	
try catch
try catch finally
try catch catch catch
try catch catch catch finally
try finally

Customer using ATM
	try{
		swipe atm card
		enter atm pin
		choose withdraw option
		enter withdraw amount
		collect cash
	}
	catch(card has a problem){
		sysout("please dial 1800 , and request for new card");
	}
	catch(pin is wrong){
		sysout("please enter valid atm pin");
	}
	catch(insufficient fund){
		sysout("please withdraw amount as per your current balance");
	}
throws

userdefined exception


public class telecom{
	public void call(long phoneNumber){
		dialing phone; // WILL FAIL
	}
}

call(0); // NO technical limitation. in storing 0 for long data type.
	// BUT HAS BUSINESS LIMITATION.




public class Banking{
	int balance=100;
	public void withdraw(int amount){
		withdraw money, deduct from balance
		// new balance = -9900 // NO technical limitation
		// banking/financial BUSINESS LIMITATION
	}
}


withdraw(  10000 );


collection of objects (String, Person,Car, integer,  float, double )
	List : indexed, duplicates
		ArrayList : fastest for reading or simple inserting in collections
		Vector : (Exactly similar to arraylist but synchronized)
			Slower than ArrayList. But ensure data consistency by synchronization
		LinkedList : fastest for editing (inserting or removing in the middle)

	Set : Unique, not-indexed
		HashSet : unordered
		LinkedHashSet : ordered
		TreeSet : sorted
		
		Restaurant order display screen : LinkedHashSet
		Airport terminal screen : TreeSet

	Map : pair of information. (string int) (String Passenger)
		HashMap		
		LinkedHashMap
		TreeMap
		Hashtable
		
		
		
Son s=new Son();
public class parent{
	// no default constructor provided, since developer already
	// wrote a constructor below
	
	public parent(String s){
		sysout(parent);
	}
}

public class son extends parent{
	public son( ){
		super(); //line automatically addded by compiler
				// to call parent construcitor with no param
				// but since it doesnt exist . its an error
		sysout( son );
	}
}

son s=new son();


when using  Set or Map(key) with user-defined data type
uniqueness check wont work
HashSet<Student> duplicate removal wont work
HashSet<String>  duplicate removal work

how does collection remove duplicates : by looking at equals and hashcode methods

String	: inbuilt complex/object data type
int		: inbuilt primitive data type
float		: inbuilt primitive data type
Student	: user-defined data type
Product


List : indexed, allow duplicates
Set : not-indexed, does not allow duplicates


ArrayList<Student> li=new ArrayList<Student> ();
// hashcode and equal method needed in Student = NO
	// hashcode and equal required if no duplicated allowed
	// Since list allows dupliate no need to write hashcode and equal

LinkedHashSet<Student> se=new LinkedHashSet<Student> ();
// hashcode and equal method needed in Student = ??????
	// hashcode and equal required if no duplicated allowed
	// since Set does not allow duplicated we NEED to write hashcode and equal

If collection program requires sorting
	implements comparable... write code for compareTo method
	applies to TreeSet or TreeMap
	
	
	